#' @title Estimate parameters of a multivariate Student's t distribution to fit data
#'
#' Mean and Covariance Matrix Estimation under Heavy Tails
#'
#' @description Estimate parameters of a multivariate Student's t distribution to fit data.
#' In particular, it will estimate the mean vector, the covariance matrix, the scatter
#' matrix, and the degrees of freedom.
#' The data can contain missing values denoted by NAs.
#' It can also consider a factor model structure on the covariance matrix.
#'
#' @param X Data matrix
#' @param factors Interger indicating number of factor dimension (default is \code{ncol(X)}, so no factor model assumption).
#' @param max_iter Interger indicating the maximum iterations of estimation method.
#' @param ptol Number (\eqn{\ge 0}) indicating the tolerance for parameter changing when judge convergence (default is \code{0.001}).
#' @param ftol Number (\eqn{\ge 0}) indicating the tolerance for objective changing when judge convergence (default is \code{Inf}).
#'             Note: it might be time consuming when use objective changing as a convergence judging criterion, especially when X is high-dimensional.
#' @param method String indicating the method of estimating \eqn{\nu}:
#'               \itemize{\item{\code{"ECM"}  - maximize the Q function w.r.t. \eqn{\nu}}
#'                        \item{\code{"ECME"} - maximize the L function w.r.t. \eqn{\nu}.}}
#' @param nu If pass a number (\eqn{> 2}), the \eqn{\nu} will be fixed to this number; if pass \code{"kurtosis"},
#'           this function will automatically find a number via the kurtosis of Student's t distribution (default is \code{NULL}, so \eqn{\nu} will be estimated via EM method.).
#' @param nu_target Number (\eqn{\ge 2}) indicating the regularized target of \eqn{\nu} (default is the estimator via kurtosis).
#' @param nu_regcoef Number (\eqn{\ge 0}), the coefficience of nu regularized term, only valid when \code{nu} is not passed (default is \code{0}).
#' @param initializer List of initial value of parameters for starting method.
#' @param return_iterates Logical value indicating whether to recode the procedure by iterations (default is \code{FALSE}).
#' @param verbose Logical value indicating whether to allow the function to print messages (default is \code{FALSE}).
#'
#' @return The estimated parameters as a list, namely, the mean vector in \code{mu}, the covariance matrix in \code{cov},
#'         the scatter matrix in \code{scatter}, and the degrees of freedom in in \code{nu}. Some additional elements
#'         may be returned if \code{return_iterates = TRUE}.
#'
#' @details By default, this function is to estimate parameters of multivariate Student's t distribution via expectation–maximization (EM) algorithm.
#'          But this function is also flexible to use when user has priori knowledge of \eqn{\nu}: one can force \eqn{\nu} to be a fixed number by passing such value to argument \code{nu},
#'          or regularize \eqn{\nu} to a give target by passing argument \code{nu_regcoef} > 0. The nu regularized term is added to the nu sub-problem as \eqn{nu_regcoef * (nu - nu_target)^2}.
#'          There is also an embedded function to estimate \eqn{\nu} via the kurtosis of \code{X}.
#'
#' @author Rui ZHOU and Daniel P. Palomar
#'
#' @references
#' Chuanhai Liu and Donald B. Rubin, “ML estimation of the t-distribution using EM and its extensions, ECM and ECME,”
#' Statistica Sinica (5), pp. 19-39, 1995.
#'
#' Rui Zhou, Junyan Liu, Sandeep Kumar, and Daniel P. Palomar, "Robust factor analysis parameter estimation,"
#' Lecture Notes in Computer Science (LNCS), 2019 <https://arxiv.org/abs/1909.12530>
#'
#' @examples
#' library(mvtnorm)  # to generate heavy-tailed data
#' library(fitHeavyTail)
#' X <- rmvt(n = 1000, df = 6)  # generate Student's t data
#' fit_mvt(X)
#'
#' @export
fit_mvt <- function(X, factors = ncol(X), max_iter = 100, ptol = 1e-3, ftol = Inf, method = "ECM",
                    nu = NULL, nu_target = NULL, nu_regcoef = 0, initializer = NULL,
                    return_iterates = FALSE, verbose = FALSE) {
  ####### error control ########
  X <- try(as.matrix(X), silent = TRUE)
  if (!is.matrix(X)) stop("\"X\" must be a matrix or can be converted to a matrix.")
  if (!all(is.na(X) | is.numeric(X))) stop("\"X\" only allows numerical or NA values.")
  if (ncol(X) <= 1) X <- X[!is.na(X), , drop = FALSE]
  if (nrow(X) <= 1) stop("Only T=1 sample!!")
  factors <- round(factors)
  max_iter <- round(max_iter)
  if (factors < 1 || factors > ncol(X)) stop("\"factors\" must be no less than 1 and no more than column number of \"X\".")
  if (max_iter < 1) stop("\"max_iter\" must be greater than 1.")
  # if (nrow(X) <= 2*ncol(X) && nu_regcoef <= 0 && is.null(nu)) warning("Small sample size! Estimation results might be inaccurate, please try regularized mode (set \"nu_regcoef\" > 0).")
  ##############################

  T <- nrow(X)
  N <- ncol(X)
  X_has_NA <- anyNA(X)
  FA_struct <- factors != N
  optimize_nu <- is.null(nu)
  if (!optimize_nu) {
    if (nu == Inf) nu <- 1e15  # for numerical stability (for the Gaussian case)
    if (nu == "kurtosis") {  # estimate nu if argument nu = "kurtosis"
      nu <- est_nu_kurtosis(X)
      if (verbose) message(sprintf("Automatically set nu = %.2f", nu))
    }
  } else  # choose nu_target if necessary
    if (is.null(nu_target)) {
      if (nu_regcoef > 0) {  # really need nu_target
        nu_target <- est_nu_kurtosis(X)
        if (verbose) message(sprintf("Automatically choose a target nu = %.2f", nu_target))
      } else  # no need to have nu_target, but assign a value to simplify following codes
        nu_target <- 0
    }

  # initialize all parameters
  alpha <- 1  # an extra variable for PX-EM acceleration
  if (optimize_nu) nu <- if (is.null(initializer$nu)) 4 else initializer$nu
  mu <- if (is.null(initializer$mu)) colMeans(X, na.rm = TRUE) else initializer$mu
  SCM <- var(X, na.rm = TRUE)
  if (FA_struct) {  # Sigma is the scatter matrix, not the covariance matrix
    SCM_eigen <- eigen(SCM, symmetric = TRUE)
    B <- if (is.null(initializer$B)) SCM_eigen$vectors[, 1:factors] %*% diag(sqrt(SCM_eigen$values[1:factors]), factors)
         else initializer$B
    psi <- if (is.null(initializer$psi)) pmax(0, diag(SCM) - diag(B %*% t(B)))
           else initializer$psi
    Sigma <- (nu-2)/nu * (B %*% t(B) + diag(psi, N))
  } else {
    Sigma <- (nu-2)/nu * SCM
  }

  #mask_notNA <- !is.na(rowSums(X))
  if (ftol < Inf) log_likelihood <- ifelse(X_has_NA,
                                           dmvt_withNA(X = X, delta = mu, sigma = Sigma / alpha, df = nu),
                                           sum(mvtnorm::dmvt(X, delta = mu, sigma = Sigma, df = nu, log = TRUE, type = "shifted")))
  snapshot <- function() {
    if (ftol < Inf)
      list(mu = mu, scatter = Sigma, nu = nu, log_likelihood = log_likelihood)
    else
      list(mu = mu, scatter = Sigma, nu = nu)
  }

  # loop
  if (return_iterates) iterations_record <- list(snapshot())
  for (iter in 1:max_iter) {
    # record the current status
    Sigma_old <- Sigma
    mu_old <- mu
    nu_old <- nu
    if (ftol < Inf) log_likelihood_old <- log_likelihood

    ## -------------- E-step --------------
    if (X_has_NA || FA_struct)
      Q <- Estep(mu, Sigma, psi, nu, X)
    else {
      X_ <- X - matrix(mu, T, N, byrow = TRUE)
      tmp <- rowSums(X_ * (X_ %*% inv(Sigma)))  # diag( X_ %*% inv(Sigma) %*% t(X_) )
      E_tau <- (nu + N) / (nu + tmp)
      ave_E_tau <- mean(E_tau)
      ave_E_tau_X <- (1/T)*as.vector(E_tau %*% X)
    }

    ## -------------- M-step --------------
    # update mu, alpha, nu
    if (X_has_NA || FA_struct) {
      mu <- Q$ave_E_tau_X / Q$ave_E_tau
      alpha <- Q$ave_E_tau
      S <- Q$ave_E_tau_XX - cbind(mu) %*% rbind(Q$ave_E_tau_X) - cbind(Q$ave_E_tau_X) %*% rbind(mu) + Q$ave_E_tau * cbind(mu) %*% rbind(mu)
      S <- S / alpha
      if (FA_struct) {
        B   <- optB(S = S, factors = factors, psi_vec = psi)
        psi <- pmax(0, diag(S - B %*% t(B)))
        Sigma <- B %*% t(B) + diag(psi, N)
      } else
        Sigma <- S
      Q_nu <- function(nu) { - (nu/2)*log(nu/2) + lgamma(nu/2) - (nu/2)*(Q$ave_E_logtau - Q$ave_E_tau) + nu_regcoef * (nu/(nu-2) - nu_target/(nu_target-2))^2 }
      if (optimize_nu) nu <- optimize(Q_nu, interval = c(2 + 1e-12, 100))$minimum
    } else {
      mu <- ave_E_tau_X / ave_E_tau
      alpha <- ave_E_tau  # acceleration
      X_ <- X - matrix(mu, T, N, byrow = TRUE)  # this is slower: sweep(X, 2, FUN = "-", STATS = mu)  #X_ <- X - rep(mu, each = TRUE)  # this is wrong?
      ave_E_tau_XX <- (1/T) * crossprod(sqrt(E_tau) * X_)  # (1/T) * t(X_) %*% diag(E_tau) %*% X_
      Sigma <- ave_E_tau_XX / alpha
      if (optimize_nu)
        nu <- switch(method,
                     "ECM" = {  # based on minus the Q function of nu
                       S <- T*(digamma((N+nu)/2) - log((N+nu)/2)) + sum(log(E_tau) - E_tau)  # S is E_log_tau-E_tau
                       Q_nu <- function(nu) { - T*(nu/2)*log(nu/2) + T*lgamma(nu/2) - (nu/2)*sum(S) + nu_regcoef * (nu/(nu-2) - nu_target/(nu_target-2))^2 }
                       optimize(Q_nu, interval = c(2 + 1e-12, 100))$minimum
                       },
                     "ECME" = {  # based on minus log-likelihood of nu with mu and sigma fixed to mu[k+1] and sigma[k+1]
                       tmp <- rowSums(X_ * (X_ %*% inv(Sigma)))  # diag( X_ %*% inv(Sigma) %*% t(X_) )
                       LL_nu <- function(nu) { - sum ( - ((nu+N)/2)*log(nu+tmp) + lgamma( (nu+N)/2 ) - lgamma(nu/2) + (nu/2)*log(nu) ) + nu_regcoef * (nu/(nu-2) - nu_target/(nu_target-2))^2 }
                       optimize(LL_nu, interval = c(2 + 1e-12, 100))$minimum
                       },
                     stop("Method unknown."))
    }

    ## -------- stopping criterion --------
    have_params_converged <-
      all(abs(mu - mu_old)       <= .5 * ptol * (abs(mu_old) + abs(mu))) &&
      abs(fnu(nu) - fnu(nu_old)) <= .5 * ptol * (abs(fnu(nu_old)) + abs(fnu(nu))) &&
      all(abs(Sigma - Sigma_old) <= .5 * ptol * (abs(Sigma_old) + abs(Sigma)))

    if (ftol < Inf) {
      log_likelihood  <- dmvt_withNA(X = X, delta = mu, sigma = Sigma, df = nu)
      has_fun_converged <- abs(log_likelihood - log_likelihood_old) <= .5 * ftol * (abs(log_likelihood) + abs(log_likelihood_old))
    } else has_fun_converged <- TRUE
    # record the current the variables/loglikelihood if required
    names(mu) <- colnames(Sigma) <- rownames(Sigma) <- colnames(X)  # add names first
    if (return_iterates) iterations_record[[iter + 1]] <- snapshot()
    if (have_params_converged && has_fun_converged) break
  }

  ## -------- return variables --------

  vars_to_be_returned <- list("mu"          = mu,
                              "cov"         = nu/(nu-2) * Sigma,
                              "nu"          = nu,
                              "scatter"     = Sigma)
  if (FA_struct) {
    rownames(B) <- names(psi) <- colnames(X)  # add name first
    vars_to_be_returned$B   <- B
    vars_to_be_returned$Psi <-  psi
  }
  if (ftol < Inf)
    vars_to_be_returned$log_likelihood <- log_likelihood
  if (return_iterates) {
    names(iterations_record) <- paste("iter", 0:(length(iterations_record)-1))
    vars_to_be_returned$iterations_record <- iterations_record
  }
  return(vars_to_be_returned)
}



fnu <- function(nu) {nu/(nu-2)}


# Expectation step
Estep <- function(mu, full_Sigma, psi, nu, X) {
  T <- nrow(X)
  N <- ncol(X)

  # to save memory size and reduce computation time
  # full_Sigma <- B %*% t(B) + diag(psi, N)
  missing_pattern <- unique(!is.na(X))
  Sigma_inv_obs <- list()
  for (i in 1:nrow(missing_pattern)) {
    mask <- missing_pattern[i, ]
    Sigma_inv_obs[[i]] <- solve(full_Sigma[mask, mask])
  }

  # init storage space
  E_tau <- E_logtau <- 0
  E_tau_X <- rep(0, N)
  E_tau_XX <- matrix(0, N, N)

  # calculate...
  X_demean <- X - matrix(mu, T, N, byrow = TRUE)
  for (i in 1:T) {

    # find missing pattern
    mask <- !is.na(X[i, ])
    Index <- indexRowOfMatrix(target_vector = mask, mat = missing_pattern)

    # calculate expectation
    tmp <- nu + rbind(X_demean[i, mask]) %*% Sigma_inv_obs[[Index]] %*% cbind(X_demean[i, mask])
    E_tau_i <- as.numeric( (nu + sum(mask)) / tmp)
    E_tau <- E_tau + E_tau_i / T

    E_logtau_i <- digamma( (nu+sum(mask))/2 ) - log(tmp/2)
    E_logtau <- E_logtau + E_logtau_i / T

    tmp <- X[i, ]
    tmp[!mask] <- mu[!mask] + full_Sigma[!mask, mask] %*% Sigma_inv_obs[[Index]] %*% X_demean[i, mask]
    E_tau_x_i <- E_tau_i * tmp
    E_tau_X <- E_tau_X + E_tau_x_i / T

    E_tau_XX <- E_tau_XX + E_tau_i * cbind(tmp) %*% rbind(tmp)
    E_tau_XX[!mask, !mask] <- E_tau_XX[!mask, !mask] + full_Sigma[!mask, !mask] -
      full_Sigma[!mask, mask] %*% Sigma_inv_obs[[Index]] %*% full_Sigma[mask, !mask]
  }
  E_tau_XX <- E_tau_XX / T

  # correct computation precision error (to be deleted!!!)
  min_eigval <- min(eigen(E_tau_XX)$values)
  diag(E_tau_XX) <- diag(E_tau_XX) - min(0, min_eigval)

  return(list(
    "ave_E_tau"    = E_tau,
    "ave_E_logtau" = as.numeric(E_logtau),
    "ave_E_tau_X"  = E_tau_X,
    "ave_E_tau_XX" = E_tau_XX
  ))
}

# assistant function
indexRowOfMatrix <- function(target_vector, mat) {
  return(which(apply(mat, 1, function(x) all.equal(x, target_vector) == "TRUE")))
}

# solve optimal nu via bisection method:
# log(nu/2) - digamma(nu/2) = y
# optimize_nu <- function(y, tol = 1e-4) {
#   if (y < 0) stop("y must be positive!")
#   L <- 1e-5
#   U <- 1000
#
#   while ((log(U)-digamma(U)) > y) U <- U*2
#   while ((log(L)-digamma(L)) < y) L <- L*2
#
#   while (1) {
#     mid <- (L + U) / 2
#     tmp <- log(mid)-digamma(mid) - y
#
#     if (abs(tmp) < tol) break
#     if (tmp > 0) L <- mid else U <- mid
#   }
#
#   return(2*mid)
# }


# a function for computing the optimal B given the psi vector
# see: Lemma 1. in LNCS paper
optB <- function(S, factors, psi_vec) {
  psi_sqrt <- sqrt(psi_vec)
  psi_inv_sqrt <- 1 / psi_sqrt
  tmp <- eigen(S * (psi_inv_sqrt%*%t(psi_inv_sqrt)))
  U <- cbind(tmp$vectors[, 1:factors])
  D <- tmp$values[1:factors]
  Z <- matrix(0, nrow(S), factors)

  for (i in 1:factors) {
    zi <- U[, i]
    Z[, i] <- zi * sqrt(max(1, D[i]) - 1) / norm(zi, "2")
  }

  B <- diag(psi_sqrt) %*% Z;
  return(B)
}

# calculate log-likelihood value with missing data
#' @importFrom mvtnorm dmvt
dmvt_withNA <- function(X, delta, sigma, df) {
  res <- 0
  for (i in 1:nrow(X)) {
    mask <- !is.na(X[i, ])
    tmp <- dmvt(x = X[i, mask], delta = delta[mask], sigma = sigma[mask, mask], df = df)
    res <- res + tmp
  }
  return(res)
}


# estimate nu via the kurtosis of each variable
excess_kurtosis_unbias <- function(x) {
  x <- as.vector(x)
  T <- length(x)
  excess_kurt <- PerformanceAnalytics::kurtosis(x, method = "fisher", na.rm = TRUE) # mean(x_demean^4) / (mean(x_demean^2))^2 - 3
  excess_kurt_unbias <- (T-1) / (T-2) / (T-3) * ((T+1)*excess_kurt + 6)  # TODO check if such bias correction is still necessary
  return(excess_kurt_unbias)
}

est_nu_kurtosis <- function(X) {
  kurt <- apply(X, 2, excess_kurtosis_unbias)
  kappa <- max(0, mean(kurt)/3)
  nu <- 2 / kappa + 4
  # in case of some funny results
  if (nu < 2) nu <- 2
  if (nu > 100) nu <- 100

  return(nu)
}
